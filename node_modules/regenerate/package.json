{
  "name": "regenerate",
  "version": "0.5.4",
  "description": "Generate JavaScript-compatible regular expressions based on a given set of Unicode symbols or code points.",
  "homepage": "http://mths.be/regenerate",
  "main": "regenerate.js",
  "keywords": [
    "regex",
    "regexp",
    "unicode",
    "generator",
    "tool"
  ],
  "licenses": [
    {
      "type": "MIT",
      "url": "http://mths.be/mit"
    }
  ],
  "author": {
    "name": "Mathias Bynens",
    "url": "http://mathiasbynens.be/"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mathiasbynens/regenerate.git"
  },
  "bugs": {
    "url": "https://github.com/mathiasbynens/regenerate/issues"
  },
  "directories": {
    "test": "tests"
  },
  "scripts": {
    "test": "node tests/tests.js"
  },
  "dependencies": {},
  "devDependencies": {
    "grunt": "~0.4.1",
    "grunt-shell": "~0.2.2",
    "istanbul": "~0.1.36",
    "qunit-clib": "~1.3.0",
    "qunitjs": "~1.11.0",
    "requirejs": "~2.1.6"
  },
  "readme": "# Regenerate [![Build status](https://travis-ci.org/mathiasbynens/regenerate.png?branch=master)](https://travis-ci.org/mathiasbynens/regenerate) [![Dependency status](https://gemnasium.com/mathiasbynens/regenerate.png)](https://gemnasium.com/mathiasbynens/regenerate)\n\n_Regenerate_ is a Unicode-aware regex generator for JavaScript. It allows you to easily generate JavaScript-compatible regular expressions based on a given set of Unicode symbols or code points.\n\nFeel free to fork if you see possible improvements!\n\n## Installation\n\nVia [npm](http://npmjs.org/):\n\n```bash\nnpm install regenerate\n```\n\nVia [Bower](http://bower.io/):\n\n```bash\nbower install regenerate\n```\n\nVia [Component](https://github.com/component/component):\n\n```bash\ncomponent install mathiasbynens/regenerate\n```\n\nIn a browser:\n\n```html\n<script src=\"regenerate.js\"></script>\n```\n\nIn [Node.js](http://nodejs.org/), and [RingoJS ‚â• v0.8.0](http://ringojs.org/):\n\n```js\nvar regenerate = require('regenerate');\n```\n\nIn [Narwhal](http://narwhaljs.org/) and [RingoJS ‚â§ v0.7.0](http://ringojs.org/):\n\n```js\nvar regenerate = require('regenerate').regenerate;\n```\n\nIn [Rhino](http://www.mozilla.org/rhino/):\n\n```js\nload('regenerate.js');\n```\n\nUsing an AMD loader like [RequireJS](http://requirejs.org/):\n\n```js\nrequire(\n  {\n    'paths': {\n      'regenerate': 'path/to/regenerate'\n    }\n  },\n  ['regenerate'],\n  function(regenerate) {\n    console.log(regenerate);\n  }\n);\n```\n\n## API\n\n### `regenerate(value1, value2, value3, ...)`\n\nThe main Regenerate function. Calling this function creates a new set that gets a chainable API.\n\n```js\nvar set = regenerate()\n  .addRange(0x60, 0x69) // add U+0060 to U+0069\n  .remove(0x62, 0x64) // remove U+0062 and U+0064\n  .add(0x1D306) // add U+1D306\nset.valueOf();\n// ‚Üí [0x60, 0x61, 0x63, 0x65, 0x66, 0x67, 0x68, 0x69, 0x1D306]\nset.toString();\n// ‚Üí '[\\\\x60-ace-i]|\\\\uD834\\\\uDF06'\nset.toRegExp();\n// ‚Üí /[\\x60-ace-i]|\\uD834\\uDF06/\n```\n\nAny arguments passed to `regenerate()` will be added to the set right away. Both code points (numbers) as symbols (strings consisting of a single Unicode symbol) are accepted.\n\n```js\nregenerate(0x1D306, 'A', '¬©', 0x2603).toString();\n// ‚Üí '[A\\\\xA9\\\\u2603]|\\\\uD834\\\\uDF06'\n```\n\n### `regenerate.prototype.add(value1, value2, value3, ...)`\n\nAny arguments passed to `add()` are added to the set. Both code points (numbers) as symbols (strings consisting of a single Unicode symbol) are accepted, as well as arrays containing values of these types.\n\n```js\nregenerate().add(0x1D306, 'A', '¬©', 0x2603).toString();\n// ‚Üí '[A\\\\xA9\\\\u2603]|\\\\uD834\\\\uDF06'\n```\n\n### `regenerate.prototype.remove(value1, value2, value3, ...)`\n\nAny arguments passed to `remove()` are removed to the set. Both code points (numbers) as symbols (strings consisting of a single Unicode symbol) are accepted, as well as arrays containing values of these types.\n\n```js\nregenerate(0x1D306, 'A', '¬©', 0x2603).remove('‚òÉ').toString();\n// ‚Üí '[A\\\\xA9]|\\\\uD834\\\\uDF06'\n```\n\nFunctions can also be passed. In that case, the result of calling the function against a code point value in the set determines whether the element should be removed (`true`) or not (`false`).\n\n```js\nregenerate(0x1D306, 'A', '¬©', 0x2603).remove(function(codePoint) {\n  return codePoint > 0xFFFF; // remove astral code points from the set\n}).toString();\n// ‚Üí '[A\\\\xA9\\\\u2603]'\n```\n\n### `regenerate.prototype.addRange(start, end)`\n\nAdds a range of code points from `start` to `end` (inclusive) to the set. Both code points (numbers) as symbols (strings consisting of a single Unicode symbol) are accepted.\n\n```js\nregenerate(0x1D306).addRange(0x00, 0xFF).toString(16);\n// ‚Üí '[\\\\0-\\\\xFF]|\\\\uD834\\\\uDF06'\n\nregenerate().addRange('A', 'z').toString();\n// ‚Üí '[A-z]'\n```\n\n### `regenerate.prototype.removeRange(start, end)`\n\nRemoves a range of code points from `start` to `end` (inclusive) from the set. Both code points (numbers) as symbols (strings consisting of a single Unicode symbol) are accepted.\n\n```js\nregenerate()\n  .addRange(0x000000, 0x10FFFF) // add all Unicode code points\n  .removeRange('A', 'z') // remove all symbols from `A` to `z`\n  .toString();\n// ‚Üí '[\\\\0-\\\\x40\\\\x7B-\\\\uD7FF\\\\uDC00-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|[\\\\uD800-\\\\uDBFF]'\n\nregenerate()\n  .addRange(0x000000, 0x10FFFF) // add all Unicode code points\n  .removeRange(0x0041, 0x007A) // remove all code points from U+0041 to U+007A\n  .toString();\n// ‚Üí '[\\\\0-\\\\x40\\\\x7B-\\\\uD7FF\\\\uDC00-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|[\\\\uD800-\\\\uDBFF]'\n```\n\n### `regenerate.prototype.difference(codePoints)`\n\nRemoves any code points from the set that are present in both the set and the given `codePoints` array. `codePoints` must be an array of numeric code point values, i.e. numbers. If you want to use symbol values (strings) as well, use `regenerate#remove()` instead.\n\n```js\nregenerate()\n  .addRange(0x00, 0xFF) // add extended ASCII code points\n  .difference([0x61, 0x73]) // remove these code points from the set\n  .toString();\n// ‚Üí '[\\0-\\x60b-rt-\\xFF]'\n```\n\n### `regenerate.prototype.intersection(codePoints)`\n\nRemoves any code points from the set that are not present in both the set and the given `codePoints` array. `codePoints` must be an array of numeric code point values, i.e. numbers.\n\n```js\nregenerate()\n  .addRange(0x00, 0xFF) // add extended ASCII code points\n  .intersection([0x61, 0x69]) // remove all code points from the set except for these\n  .toString();\n// ‚Üí '[ai]'\n```\n\n### `regenerate.prototype.contains(value)`\n\nReturns `true` if the given value is part of the set, and `false` otherwise. Both code points (numbers) as symbols (strings consisting of a single Unicode symbol) are accepted.\n\n```js\nvar set = regenerate().addRange(0x00, 0xFF);\nset.contains('A');\n// ‚Üí true\nset.contains(0x1D306);\n// ‚Üí false\n```\n\n### `regenerate.prototype.toString()`\n\nReturns a string representing (part of) a regular expression that matches all the symbols mapped to the code points within the set.\n\n```js\nregenerate(0x1D306, 0x1F4A9).toString();\n// ‚Üí '\\\\uD834\\\\uDF06|\\\\uD83D\\\\uDCA9'\n```\n\n### `regenerate.prototype.toRegExp()`\n\nReturns a regular expression that matches all the symbols mapped to the code points within the set.\n\n```js\nvar regex = regenerate(0x1D306, 0x1F4A9).toRegExp();\n// ‚Üí /\\uD834\\uDF06|\\uD83D\\uDCA9/\nregex.test('ùåÜ');\n// ‚Üí true\nregex.test('A');\n// ‚Üí false\n```\n\n**Note:** This probably shouldn‚Äôt be used. Regenerate is intended as a tool that is used as part of a build process, not at runtime.\n\n### `regenerate.prototype.valueOf()` or `regenerate.prototype.toArray()`\n\nReturns a sorted array of unique code points in the set.\n\n```js\nregenerate(0x1D306)\n  .addRange(0x60, 0x65)\n  .add(0x59, 0x60) // note: 0x59 is added after 0x65, and 0x60 is a duplicate\n  .valueOf();\n// ‚Üí [0x59, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x1D306]\n```\n\n### `regenerate.version`\n\nA string representing the semantic version number.\n\n### `regenerate.fromCodePoints(codePoints)`\n\nThis function takes an array of numerical code point values and returns a string representing (part of) a regular expression that would match all the symbols mapped to those code points.\n\n```js\n// Create a regular expression that matches any of the given code points:\nregenerate.fromCodePoints([0x1F604, 0x1F605, 0x1F606, 0x1F607]);\n// ‚Üí '\\\\uD83D[\\\\uDE04-\\\\uDE07]'\n```\n\n### `regenerate.fromCodePointRange(start, end)`\n\nThis function takes a `start` and an `end` code point value, and returns a string representing (part of) a regular expression that would match all the symbols mapped to the code points within the range _[start, end]_ (inclusive).\n\n```js\n// Create a regular expression that matches any code point in the given range:\nregenerate.fromCodePointRange(0x1F604, 0x1F607);\n// ‚Üí '\\\\uD83D[\\\\uDE04-\\\\uDE07]'\n\n// Create a regular expression that matches any Unicode code point:\nregenerate.fromCodePointRange(0x000000, 0x10FFFF);\n// ‚Üí '[\\\\0-\\\\uD7FF\\\\uDC00-\\\\uFFFF]|[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|[\\\\uD800-\\\\uDBFF]'\n```\n\n### `regenerate.fromCodePointRanges(ranges)`\n\nThis function takes an array of code point ranges or separate code points, and returns a string representing (part of) a regular expression that would match all the symbols mapped to the code points within the listed code points or code point ranges.\n\n```js\n// Create a regular expression based on a dynamically created range of code points:\nregenerate.fromCodePointRanges([\n  [0x00, 0xFF],          // range\n  [0x2603, 0x2608],      // range\n  0x1F4A9, // separate code point\n  0x1F4BB  // separate code point\n]);\n// ‚Üí '[\\\\0-\\\\xFF\\\\u2603-\\\\u2608]|\\\\uD83D[\\\\uDCA9\\\\uDCBB]'\n```\n\n```js\n// Allow all Unicode symbols except U+2603 SNOWMAN and U+1F4A9 PILE OF POO:\nregenerate.fromCodePointRanges([\n  [0x0000, 0x2602],  // skip 0x2603\n  [0x2604, 0x1F4A8], // skip 0x1F4A9\n  [0x1F4AA, 0x10FFFF]\n]);\n// ‚Üí '[\\\\0-\\\\u2602\\\\u2604-\\\\uD7FF\\\\uDC00-\\\\uFFFF]|[\\\\uD800-\\\\uD83C\\\\uD83E-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|\\\\uD83D[\\\\uDC00-\\\\uDCA8\\\\uDCAA-\\\\uDFFF]|[\\\\uD800-\\\\uDBFF]'\n```\n\n### `regenerate.fromSymbols(symbols)`\n\nThis function takes an array of strings that each contain a single Unicode symbol. It returns a string representing (part of) a regular expression that would match all those symbols.\n\n```js\n// Create a regular expression that matches any of the given Unicode symbols:\nregenerate.fromSymbols(['ùêÄ', 'ùêÅ', 'ùêÇ', 'ùêÉ', 'ùêÑ']);\n// ‚Üí '\\\\uD835[\\\\uDC00-\\\\uDC04]'\n```\n\n### `regenerate.fromSymbolRange(start, end)`\n\nThis function takes a `start` and an `end` string which each contain a single Unicode symbol. It returns a string representing (part of) a regular expression that would match all the symbols within the range _[start, end]_ (inclusive).\n\n```js\n// Create a regular expression that matches any Unicode symbol in the given range:\nregenerate.fromSymbolRange('ùêè', 'ùêü');\n// ‚Üí '\\\\uD835[\\\\uDC0F-\\\\uDC1F]'\n```\n\n### `regenerate.fromSymbolRanges(ranges)`\n\nThis function takes an array of symbol ranges or separate strings, each containing a single Unicode symbol, and returns a string representing (part of) a regular expression that would match all the symbols within the listed symbols or symbol ranges.\n\n```js\n// Create a regular expression based on a dynamically created range of code points:\nregenerate.fromSymbolRanges([\n  ['\\0', '\\xFF'],           // range\n  ['\\u2603', '\\u2608'],     // range\n  '\\uD83D\\uDCA9', // separate symbol\n  '\\uD83D\\uDCBB'  // separate symbol\n]);\n// ‚Üí '[\\\\0-\\\\xFF\\\\u2603-\\\\u2608]|\\\\uD83D[\\\\uDCA9\\\\uDCBB]'\n```\n\n### `regenerate.range(start, end)`\n\nThis function takes a `start` and an `end` number and returns an array of numbers progressing from `start` up to and including `end`, i.e. all the numbers within the range _[start, end]_ (inclusive).\n\n```js\n// Create an array containing all extended ASCII code points:\nregenerate.range(0x00, 0xFF);\n// ‚Üí [0x00, 0x01, 0x02, 0x03, ..., 0xFF]\n```\n\n### `regenerate.ranges(ranges)`\n\nThis function takes an array of code point ranges or separate code points, and returns an array containing all the code points within the listed code points or code point ranges.\n\n```js\n// Create a regular expression based on a dynamically created range of code points:\nvar codePoints = regenerate.ranges([\n  [0x00, 0xFF], // ‚Üí 0x00, 0x01, 0x02, 0x03, ‚Ä¶, 0xFC, 0xFD, 0xFE, 0xFF\n  [0x2603, 0x2608], // ‚Üí 0x2603, 0x2604, 0x2605, 0x2606, 0x2607, 0x2608\n  0x1F4A9, // add U+1F4A9 PILE OF POO\n  0x1F4BB // add U+1F4BB PERSONAL COMPUTER\n]);\n// ‚Üí [0x00, 0x01, ‚Ä¶, 0xFE, 0xFF, 0x2603, 0x2604, ‚Ä¶, 0x2607, 0x2608, 0x1F4A9, 0x1F4BB]\nregenerate.fromCodePoints(codePoints);\n// ‚Üí '[\\\\0-\\\\xFF\\\\u2603-\\\\u2608]|\\\\uD83D[\\\\uDCA9\\\\uDCBB]'\n```\n\n### `regenerate.contains(array, value)`\n\nReturns `true` if `array` contains `value`, and `false` otherwise.\n\n```js\nvar ASCII = regenerate.range(0x00, 0xFF); // extended ASCII\n// ‚Üí [0x00, 0x01, 0x02, 0x03, ..., 0xFF]\nregenerate.contains(ASCII, 0x61);\n// ‚Üí true\nregenerate.contains(ASCII, 0x1D306);\n// ‚Üí false\n```\n\n### `regenerate.difference(array1, array2)`\n\nReturns an array of `array1` elements that are not present in `array2`.\n\n```js\nregenerate.difference(\n  [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06],\n  [0x01, 0x03, 0x05]\n);\n// ‚Üí [0x00, 0x02, 0x04, 0x06]\n```\n\n### `regenerate.intersection(array1, array2)`\n\nReturns an array of unique elements that are present in both `array1` and `array2`.\n\n```js\nregenerate.intersection(\n  [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06],\n  [0x01, 0x03, 0x05, 0x07]\n);\n// ‚Üí [0x01, 0x03, 0x05]\n```\n\n### `regenerate.add(array, value)`\n\nExtends `array` based on `value` as follows:\n\n* If `value` is a code point (i.e. a number), it‚Äôs appended to `array`.\n* If `value` is a symbol (i.e. a string containing a single Unicode symbol), its numeric code point value is appended to `array`.\n* If `value` is an array, all its values are added to `array` following the above steps.\n\n```js\nregenerate.add(\n  [0x00, 0x1D306],\n  0x41\n);\n// ‚Üí [0x00, 0x1D306, 0x41]\n\nregenerate.add(\n  [0x00, 0x1D306],\n  'A'\n);\n// ‚Üí [0x00, 0x1D306, 0x41]\n\nregenerate.add(\n  [0x00, 0x1D306],\n  [0x61, 0x203B, 'A']\n);\n// ‚Üí [0x00, 0x1D306, 0x61, 0x203B, 0x41]\n```\n\n### `regenerate.remove(array, value)`\n\nRemoves values from `array` based on `value` as follows:\n\n* If `value` is a code point (i.e. a number), it‚Äôs removed from `array`.\n* If `value` is a symbol (i.e. a string containing a single Unicode symbol), its numeric code point value is removed from `array`.\n* If `value` is an array, all its values are removed from `array` following on the above steps.\n\n```js\nregenerate.remove(\n  [0x00, 0x1D306, 0x41],\n  0x41\n);\n// ‚Üí [0x00, 0x1D306]\n\nregenerate.remove(\n  [0x00, 0x1D306, 0x41],\n  'A'\n);\n// ‚Üí [0x00, 0x1D306]\n\nregenerate.remove(\n  [0x00, 0x1D306, 0x61, 0x203B, 0x41],\n  [0x61, 0x203B, 'A']\n);\n// ‚Üí [0x00, 0x1D306]\n```\n\n## Combine Regenerate with other libraries\n\nRegenerate gets even better when combined with other libraries such as [Punycode.js](http://mths.be/punycode). Here‚Äôs an example where [Punycode.js](http://mths.be/punycode) is used to convert a string into an array of code points, that is then passed on to Regenerate:\n\n```js\nvar regenerate = require('regenerate');\nvar punycode = require('punycode');\n\nvar string = 'Lorem ipsum dolor sit amet.';\n// Get an array of all code points used in the string:\nvar codePoints = punycode.ucs2.decode(string);\n\n// Generate a regular expression that matches any of the symbols used in the string:\nregenerate(codePoints).toString();\n// ‚Üí '[\\\\x20\\\\x2ELad-eil-mo-pr-u]'\n```\n\n## Support\n\nRegenerate has been tested in at least Chrome 27-29, Firefox 3-22, Safari 4-6, Opera 10-12, IE 6-10, Node.js v0.10.0, Narwhal 0.3.2, RingoJS 0.8-0.9, PhantomJS 1.9.0, and Rhino 1.7RC4.\n\n## Unit tests & code coverage\n\nAfter cloning this repository, run `npm install` to install the dependencies needed for Regenerate development and testing. You may want to install Istanbul _globally_ using `npm install istanbul -g`.\n\nOnce that‚Äôs done, you can run the unit tests in Node using `npm test` or `node tests/tests.js`. To run the tests in Rhino, Ringo, Narwhal, and web browsers as well, use `grunt test`.\n\nTo generate [the code coverage report](http://rawgithub.com/mathiasbynens/regenerate/master/coverage/regenerate/regenerate.js.html), use `grunt cover`.\n\n## Author\n\n| [![twitter/mathias](http://gravatar.com/avatar/24e08a9ea84deb17ae121074d0f17125?s=70)](http://twitter.com/mathias \"Follow @mathias on Twitter\") |\n|---|\n| [Mathias Bynens](http://mathiasbynens.be/) |\n\n## License\n\nRegenerate is available under the [MIT](http://mths.be/mit) license.\n",
  "readmeFilename": "README.md",
  "_id": "regenerate@0.5.4",
  "_from": "regenerate@~0.5.4"
}
